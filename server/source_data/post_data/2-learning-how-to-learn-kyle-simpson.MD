### Learning how to learn, with Kyle Simpson

getify

Incentivize the deeper answers to the question.

What we currently incentivize grinding out features, but not understanding

if you do not know why a piece of code works, you dont have any hope of fixing it when it breaks

Instead of understanding the problem, we often times jump directly to the solution, without understanding the fundumental cause.

A developer will seek first to fix the problem, and then understand. Engineers should think in the reverse.

There is some conflict between understanding and getting things done. Its almost impossible to do both in the MakerSquare program.

Many people use the word learn, but really mean memorize.

The more important task is to understand the fundumental concepts, not just the memorized concepts.

Reconstruct things from first-principles.

We know we can use the get method in Backbone, but understanding what that method is actually doing is learning.

Learn, don't memorize.

"MakerSquare wants to produce engineers that have a deeper level of curiosity and understanding than any of your peers" _KS


2 most important principles to take away from a learning environment:
How to learn - the practices by which you go through of asking questions to gain true conceptuatl understanding. here is a problem, you must understand how to solve that problem, not just the solution to that problem.
How to want to learn - how to establish a motivation for learning. Good job with good pay will get you in the door. Figure out how to be better at the job that you have. Kyle is concerned about us being an uncommon level of engineer - we should have an unbelievable thirst for understanding at a deeper level. Self-motivation is key. Money wont always be the motivating factor. Natural curiosity is great gift and privledge.

You can build intrisic motivating factors through habit making. You can become more curious and want to learn things more deeply. Go look at the source code for backbone and angular, to understand what it is doing. Dont stop with the answer to the first question. Keep asking questions to create a how to learn and how to want to learn instinct.

Some observations that may help us along the way:

Challenge is to keep going after graduation. Learning doesnt stop after MKS. Preparing to learn here, real learning is in the real world.

Arthur has 3 laws: the 3rd law is:
Any sufficiently advanced technology is indistinguishable from magic.

Any sufficiently unlearned technology is indisinguishable from magic. Unlearned technology appears magical. It is a choice to not learn. Conjuring is tiring.

CS principles can be applied to prove that there are infinite number of programs that will accomplish the same result. Which one is the appropriate solution? What is the right code?

Code submitted to the js engine is a suggestion to the engine about what you want to happen. JS will actually run that shit how it wants.

What difference does it make what program I write? JS engine doesnt care anyway. The source code that we write is a form of communication with other people. A communication with other team members and even, our future-selves. How can I create code that better communicates and teaches itself to whoever reads it?" - KS"

Can someone fresh read this code and understand it?

Never accidentally exceed your understanding.

Learn the problem deeper so that you can teach it better in the code that you write.

Understanding of the code is the primary metric of the quality of the code.

Learn something deeper because you have to teach it to other people. 

Don't treat things as black-boxes. Understand the wheel that you put onto the car.

"do or do not, there is no try" - yoda.

"learn or churn, there is no do" - KS - no more skating by doing the same thing that you have always done.

Find a balance a mix between learning and doing. Doing only one will not serve you.

mHow to look at core functions like arr.pop, arr.push - spidermonkey for Mozilla is the js engine.





